package org.paradox.query.impl;

import java.io.IOException;
import java.util.BitSet;
import java.util.Iterator;
import java.util.Stack;

import org.antlr.v4.runtime.ANTLRErrorListener;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.paradox.query.Expression;
import org.paradox.query.ExpressionFactory;
import org.paradox.schema.Schema;
import org.paradox.schema.SchemaValidationException;

import antlr4.generated.NoSQLBaseListener;
import antlr4.generated.NoSQLLexer;
import antlr4.generated.NoSQLParser;
import antlr4.generated.NoSQLParser.AggregateTermContext;
import antlr4.generated.NoSQLParser.AliasContext;
import antlr4.generated.NoSQLParser.AndContext;
import antlr4.generated.NoSQLParser.AvgContext;
import antlr4.generated.NoSQLParser.BindParamContext;
import antlr4.generated.NoSQLParser.CountContext;
import antlr4.generated.NoSQLParser.DecimalValueContext;
import antlr4.generated.NoSQLParser.EqualsContext;
import antlr4.generated.NoSQLParser.EqualsIgnoreCaseContext;
import antlr4.generated.NoSQLParser.ExistsContext;
import antlr4.generated.NoSQLParser.FieldNameContext;
import antlr4.generated.NoSQLParser.FieldPathContext;
import antlr4.generated.NoSQLParser.GreaterContext;
import antlr4.generated.NoSQLParser.GreaterOrEqualContext;
import antlr4.generated.NoSQLParser.GroupByClauseContext;
import antlr4.generated.NoSQLParser.IntegerValueContext;
import antlr4.generated.NoSQLParser.IsNotNullContext;
import antlr4.generated.NoSQLParser.IsNullContext;
import antlr4.generated.NoSQLParser.LessContext;
import antlr4.generated.NoSQLParser.LessOrEqualContext;
import antlr4.generated.NoSQLParser.LikeContext;
import antlr4.generated.NoSQLParser.LimitClauseContext;
import antlr4.generated.NoSQLParser.MaxContext;
import antlr4.generated.NoSQLParser.MinContext;
import antlr4.generated.NoSQLParser.NotContext;
import antlr4.generated.NoSQLParser.OrContext;
import antlr4.generated.NoSQLParser.OrderByClauseContext;
import antlr4.generated.NoSQLParser.OrderByTermContext;
import antlr4.generated.NoSQLParser.ProjectionsContext;
import antlr4.generated.NoSQLParser.RootPathContext;
import antlr4.generated.NoSQLParser.SelectStatementContext;
import antlr4.generated.NoSQLParser.SkipClauseContext;
import antlr4.generated.NoSQLParser.StringValueContext;
import antlr4.generated.NoSQLParser.SumContext;
import antlr4.generated.NoSQLParser.TypeNameContext;
import antlr4.generated.NoSQLParser.WhereClauseContext;

/**
 * Builds a {@link Select select statement} by parsing a SQL-like string.
 * The grammar for SQL-like string is defined using ANTLR. 
 * <p>
 * This builder listens as nodes of Abstract Syntax Tree (AST) generated by ANTLR 
 * from an input query string are walked. On each AST node, this builder 
 * creates appropriate types of {@link Expression query expression} and populates
 * a {@link Select select} data structure. The intermediate {@link Expression expressions}
 * are maintained in an internal Stack machine.
 * <p>
 * The concrete expressions to be created are controlled by a {@link ExpressionFactory factory}.
 * <br>
 * <b>Semantic Validation</b>: If a schema is provided then each field path expression is validated
 * as they are encountered in the SQL string.
 * 
 * @author pinaki poddar
 *
 */
public class SelectBuilder extends NoSQLBaseListener implements ANTLRErrorListener {
	private final Stack<Expression<?>> _stack;
	private final ExpressionFactory _factory;
	private Select _select;
	private final Schema _schema;
	
	// a state to determine how field paths on teh stack are to be treated
	private static enum ParseClause {PROJECTION, WHERE, ORDER_BY, GROUP_BY};
	private ParseClause _parseCtx = null;
	private NoSQLLexer _lexer;
	
	
	
	public SelectBuilder(Schema schema, ExpressionFactory factory) {
		_stack = new Stack<Expression<?>>();
		_schema = schema;
		_factory = factory;
		
	}
	
	/**
	 * Compiles the given SQL-like query string into a Select data structure. 
	 * If a schema is available 
	 * 
	 * @return a select populated with parsed expressions
	 * @throws IOException if the given sql string can not be read
	 * SchemaValidationException the name tokens are not semantically valid, for example  
	 */
	public Select parse(String sql) throws IOException, SchemaValidationException {
		synchronized (_stack) {
			_select = new Select(sql);
			ANTLRInputStream in = new ANTLRInputStream(sql);
			_lexer    = new NoSQLLexer(in);
			CommonTokenStream tokens = new CommonTokenStream(_lexer);
			NoSQLParser parser = new NoSQLParser(tokens);
			ParseTree ast = parser.selectStatement(); // parse the statement
			new ParseTreeWalker().walk(this, ast);
		}
		return _select;
	}
	
	/**
	 * A root path is designated by '*'. At this stage, the name of the candidate type is not known
	 * and the select is marked to use the candidate path. The actual candidate will be
	 * resolved when {@link #exitTypeName(TypeNameContext) type name} is resolved.
	 */
	
	public void exitRootPath(RootPathContext ctx) {
		_select.setCandidateTerm();
	}

	/**
	 * Field name segment either appends to an existing field path on the stack or starts
	 * a new path. Leaves the new path on the stack.
	 */
	
	public void exitFieldName(FieldNameContext ctx) {
		Expression.Path<?> previous = peek(Expression.Path.class);
		Expression.Path<?> path = (previous == null) ? _factory.newPath(ctx.getText()) 
				                                     : pop(Expression.Path.class).newPath(ctx.getText());
		push(path);
	}
	
	/**
	 * When a new field path is entered, if a previous term is on the stack (may happen during projections involving
	 * aliased aggregates, for example), then it is handled by adding to the right place on the select structure. 
	 */
	
	public void enterFieldPath(FieldPathContext ctx) {
		if (!_stack.isEmpty()) {
			if (_parseCtx == ParseClause.PROJECTION) {
				Object term = _stack.pop();
			    if (term instanceof Expression.Path) {
			    	Expression.Path<?> field = (Expression.Path<?>)term;
					validatePath(field);
					_select.addFieldTerm(field);
				} else if (term instanceof Expression.Aggregate) {
					Expression.Aggregate<?> aggregate = (Expression.Aggregate<?>)term;
					validatePath((Expression.Path<?>)aggregate.getArgument(0));
					_select.addAggregateTerm(aggregate);
				}
			}
		}
	}

	
	public void exitFieldPath(FieldPathContext ctx) {
		validatePath(peek(Expression.Path.class));
		 if (_parseCtx == ParseClause.GROUP_BY) {
			_select.addGroupByTerm(pop(Expression.Path.class));
		}
	}
	
	
	
	public void enterProjections(ProjectionsContext ctx) {
		_parseCtx = ParseClause.PROJECTION;
	}
	
	
	public void exitProjections(ProjectionsContext ctx) {
		_parseCtx = null;
		if (_stack.isEmpty()) return;
		do {
			Expression<?> term = _stack.pop();
			if (term instanceof Expression.Candidate) {
				// do nothing as placeholder candidate has been added during exitRoot and will be resolved at exitTypeName
		    } else if (term instanceof Expression.Path) {
				_select.addFieldTerm((Expression.Path<?>)term);
			} else if (term instanceof Expression.Aggregate) {
				_select.addAggregateTerm((Expression.Aggregate<?>)term);
			} else {
				printStack();
				throw new IllegalStateException();
			}
		} while (!_stack.isEmpty());
		
		assertEmptyStack();
	}



	
	public void enterWhereClause(WhereClauseContext ctx) {
		assertEmptyStack();
	}
	
	
	public void exitWhereClause(WhereClauseContext ctx) {
		_select.setPredicate(pop(Expression.Predicate.class));
	}

	
	public void exitIsNotNull(IsNotNullContext ctx) {
		Expression.Path<?> path = pop(Expression.Path.class);
		push(_factory.newNot(_factory.newIsNull(path)));
	}

	
	public void exitIsNull(IsNullContext ctx) {
		Expression.Path<?> path = pop(Expression.Path.class);
		push(_factory.newIsNull(path));
	}

	
	@SuppressWarnings("unchecked")
	public void exitGreater(GreaterContext ctx) {
		Expression.Value<Number> rhs   = pop(Expression.Value.class);
		Expression.Path<?> lhs    = pop(Expression.Path.class);
		push(_factory.newGreater(lhs, rhs));
	}

	
	@SuppressWarnings("unchecked")
	public void exitLess(LessContext ctx) {
		Expression.Value<Number> rhs   = pop(Expression.Value.class);
		Expression.Path<?> lhs    = pop(Expression.Path.class);
		push(_factory.newLess(lhs, rhs));
	}

	public void exitIntegerValue(IntegerValueContext ctx) {
		push(_factory.newConstant(Integer.parseInt(ctx.getText())));
		
	}
	
	public void exitMin(MinContext ctx) {
		push(_factory.newMin(pop(Expression.Path.class)));
		
	}
	
	public void exitOrderByTerm(OrderByTermContext ctx) {
		_select.addOrderByTerm(pop(Expression.Path.class));
	}

	
	public void exitSkipClause(SkipClauseContext ctx) {
		_select.setSkip((Integer)pop(Expression.Constant.class).getValue());
	}

	
	public void exitCount(CountContext ctx) {
		push(_factory.newCount(pop(Expression.Path.class)));
	}
	
	
	public void exitStringValue(StringValueContext ctx) {
		push(_factory.newConstant(strip(ctx.getText(), '\'')));
	}

	static String strip(String s, char q) {
		return (s != null && s.length() > 1 && s.charAt(0) == q && s.charAt(s.length()-1) == q)
			? s.substring(1, s.length()-1) : s;
	}
	
	
	public void exitSum(SumContext ctx) {
		push(_factory.newSum(pop(Expression.Path.class)));
	}
	
	
	public void exitAvg(AvgContext ctx) {
		push(_factory.newAvg(pop(Expression.Path.class)));
	}


	
	public void exitMax(MaxContext ctx) {
		push(_factory.newMax(pop(Expression.Path.class)));
		
	}

	
	public void exitAlias(AliasContext ctx) {
		peek(Expression.Aggregate.class).setAlias(ctx.getText());
	}


	
	public void exitEquals(EqualsContext ctx) {
		Expression.Value<?> rhs   = pop(Expression.Value.class);
		Expression.Path<?> lhs    = pop(Expression.Path.class);
		push(_factory.newEqual(lhs, rhs));
	}

	
	public void exitEqualsIgnoreCase(EqualsIgnoreCaseContext ctx) {
		Expression.Value<?> rhs   = pop(Expression.Value.class);
		Expression.Path<?> lhs    = pop(Expression.Path.class);
		push(_factory.newEqualIgnoreCase(lhs, rhs));
	}

	
	public void exitOr(OrContext ctx) {
		Expression.Predicate rhs = pop(Expression.Predicate.class);
		Expression.Predicate lhs = pop(Expression.Predicate.class);
		push(_factory.newOr(lhs, rhs));
	}


	
	public void exitOrderByClause(OrderByClauseContext ctx) {
		assertEmptyStack();
	}


	
	public void exitBindParam(BindParamContext ctx) {
		push(_factory.newBindParameter(ctx.getText()));
		
	}

	@SuppressWarnings("unchecked")
	public void exitLike(LikeContext ctx) {
		Expression.Value<String> rhs   = pop(Expression.Value.class);
		Expression.Path<?> lhs    = pop(Expression.Path.class);
		push(_factory.newLike(lhs, rhs));
	}

	public void exitDecimalValue(DecimalValueContext ctx) {
		push(_factory.newConstant(Double.parseDouble(ctx.getText())));
	}

	public void exitAnd(AndContext ctx) {
		Expression.Predicate rhs = pop(Expression.Predicate.class);
		Expression.Predicate lhs = pop(Expression.Predicate.class);
		push(_factory.newAnd(lhs, rhs));
	}

	public void exitNot(NotContext ctx) {
		push(_factory.newNot(pop(Expression.Predicate.class)));
	}

	/**
	 * The candidate is now available and select is set accordingly.
	 * 
	 * @see Select#setRoot(org.paradox.query.Expression.Candidate)
	 */
	
	public void exitTypeName(TypeNameContext ctx) {
		Expression.Candidate<?> candidate = _factory.newCandidate(ctx.getText());
		validateType(candidate);
		_select.setRoot(candidate);
		// now projection paths can be validated
		if (_select.hasPaths()) {
			Iterator<Expression.Path<?>> paths = _select.getFieldTerms();
			while (paths.hasNext()) {
				validatePath(paths.next());
			}
		} else if (_select.hasAggregates()) {
			Iterator<Expression.Aggregate<?>> aggregates = _select.getAggregateTerms();
			while (aggregates.hasNext()) {
				Expression.Path< ?> path = (Expression.Path< ?>)aggregates.next().getArgument(0);
				validatePath(path);
			}
		}
	}

	 
	public void exitSelectClause(NoSQLParser.SelectClauseContext ctx) { 
		assertEmptyStack();
	}

	
	public void exitSelectStatement(SelectStatementContext ctx) {
		assertEmptyStack();
	}
	
	@SuppressWarnings("unchecked")
	public void exitLessOrEqual(LessOrEqualContext ctx) {
		Expression.Value<Number> rhs   = pop(Expression.Value.class);
		Expression.Path<?> lhs    = pop(Expression.Path.class);
		push(_factory.newLessOrEqual(lhs, rhs));
	}

	public void exitExists(ExistsContext ctx) {
		push(_factory.newIsNull(pop(Expression.Path.class)));
	}

	public void exitAggregateTerm(AggregateTermContext ctx) {
		// do nothing
	}

	@SuppressWarnings("unchecked")
	public void exitGreaterOrEqual(GreaterOrEqualContext ctx) {
		Expression.Value<Number> rhs   = pop(Expression.Value.class);
		Expression.Path<?> lhs    = pop(Expression.Path.class);
		push(_factory.newGreaterOrEqual(lhs, rhs));
	}
	
	public void enterGroupByClause(GroupByClauseContext ctx) {
		_parseCtx = ParseClause.GROUP_BY;
	}
	
	
	public void exitGroupByClause(GroupByClauseContext ctx) {
		_parseCtx = null;
	}
	
	
	public void exitLimitClause(LimitClauseContext ctx) {
		_select.setLimit((Integer)pop(Expression.Constant.class).getValue());	
	}
	
	 
	public void exitDesc(NoSQLParser.DescContext ctx) { 
		peek(Expression.Path.class).setDescendingOrder();
	}
	
	

	
	public void visitErrorNode(ErrorNode error) {
		Token token = error.getSymbol();
		int n = token.getStartIndex();
		int l = token.getText().length();
		String sql = _select.getSQL();
		String message = "Syntax error in SQL [" + sql + "]";
		if (n != -1) {
		  message = "Encountered [" + token.getText() + "] at position " +  n + " in SQL [" 
		          + sql.substring(0,n) + "^" + token.getText() + "^ " + sql.substring(n+l) + "]";
		}
		
		throw new RuntimeException(message);
	}


	
	/** -----------------------------------------------------------------------
	 *      Stack Management
	 *  
	 *  Basic stack operations with sanity check for expected stack state and
	 *  type of its top element 
	 *  -----------------------------------------------------------------------    	
	 */
	/**
	 * Push the given element to the stack
	 * @param expr non-null expression
	 */
	void push(Expression<?> expr) {
		if (expr == null) 
			throw new IllegalArgumentException("Can not push null expression");
		_stack.push(expr);
	}

	/** 
	 * Peeks for an element of the given type.
	 * @param cls expected type of the top element on the stack
	 * @return the top element after casting. 
	 * If the top element is not of expected type or there is no element at all, returns null 
	 * 
	 */
	<X extends Expression<?>> X peek(Class<X> cls) {
		if (_stack.isEmpty()) 
			return null;
		if (cls.isInstance(_stack.peek())) {
			return cls.cast(_stack.peek());
		} else {
			return null;
		}
	}
	
	/** 
	 * Pops an element of the given type.
	 * @param cls expected type of the top element on the stack
	 * @return the top element after casting 
	 * @exception IllegalStateException if the stack is empty
	 * or the top element is not assignable to the given expected type
	 * 
	 */
	<X extends Expression<?>> X pop(Class<X> cls) {
		if (_stack.isEmpty()) 
			throw new IllegalStateException("Expecting an element of " + cls + " but the stack is empty");
		if (cls.isInstance(_stack.peek())) {
			return cls.cast(_stack.pop());
		} else {
			String message = _stack.peek() + " is not instance of " + cls;
			printStack();
			throw new IllegalStateException(message);
		}
	}
	
	/**
	 * Asserts that the stack is empty.
	 */
	void assertEmptyStack() {
		if (!_stack.isEmpty()) {
			int size = _stack.size();
			printStack();
			throw new IllegalStateException("Stack should have been empty but has " + size + " elements");
		}
	}
	
	void printStack() {
		while (!_stack.isEmpty()) {
			System.err.println(_stack.pop());
		}
	}
	
	String toString(Object obj) {
		return obj == null ? "null" : obj.toString() + '(' + obj.getClass() + ')';
	}
	
	/**
	 * Validates the given type only if schema has been set.
	 */
	void validateType(Expression.Candidate<?> candidate) {
		if (_schema == null) return;
		_schema.validateType(candidate.getName());
	}
	
	/**
	 * Validates the given path only if schema has been set and the select candidate is available i.e. {@code FROM}
	 * clause has been parsed.
	 */
	void validatePath(Expression.Path<?> path) {
		if (_schema == null) return;
		if (_select.getCandidate() == null) return;
		_schema.validatePath(_select.getCandidate().getName(), path.toString());
	}

	
	public void syntaxError(Recognizer<?, ?> recognizer,
			Object offendingSymbol, int line, int charPositionInLine,
			String msg, RecognitionException e) {
		
		throw e;
		
	}

	
	public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex,
			int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
		// TODO Auto-generated method stub
		
	}

	
	public void reportAttemptingFullContext(Parser recognizer, DFA dfa,
			int startIndex, int stopIndex, BitSet conflictingAlts,
			ATNConfigSet configs) {
		// TODO Auto-generated method stub
		
	}

	
	public void reportContextSensitivity(Parser recognizer, DFA dfa,
			int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
		// TODO Auto-generated method stub
		
	}
}
